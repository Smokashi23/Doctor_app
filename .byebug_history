c
role
n
role
n
role
c
params
n
params
n
c
n
response.status
response
slot
params
n
params
c
params
c
n
params
n
params
c
n
c
c\
@appointment
n
c
response.body
user.role
c
 login admin_user
user.role.role_name
c
login_in admin_user
user.role.role_name
c
response
response.body
user.role.role_name
c
response.body
user.role.role_name
c
user.role.role_name
c
 user.valid?
  user = User.new(password: "Password") 
user.valid?
user.id
user,id
User.id
User.password
user.password
c
user.new_email
user.email
response.body
user.id
use.id
user.id?
c
id: user.id,
  new_email = "test@example.com"
c
 elsif @user.doctor?
c
elsif @user.doctor?
 elsif @user.doctor?
c
@appts = Appointment.includes(:slot, :user).where(slots: { user_id: @user.id })
 @user.doctor?
c
current_user
params
c
@status
status == "Confirmed"
@status
@appointment
c
@status = @appointment.status
@appointment = Appointment.find_by(id: params[:id])
params
c
 c
c
status.update!(params[:status])
status.update(params[:status])
params[:status]
c
cd
c
params
c
params[:status]
params
c
Appointment.find_by(id: params[:id])
params
para,s
c
@appt
appt
c
exit
role.role_name
ROLES[:admin]
ROLES[:admin
c
new_email
user.email
response.body
response
c
user.admin?
user.role
c
user.role
user.admin?
user
c
response
c
user.role
continue
response
continue
valid_params
response
continue
user.role.role_name
user.admin?
continue
response
continue
Role.pluck(:role_name)
Role.last
Role.count
User.last
User.count
user
response.status
response
continue
token
next
continue
header
token
next
continue
token
JWT.decode(token, Rails.application.credentials[:secret_key_base] )
next
header
next
request.headers
request
